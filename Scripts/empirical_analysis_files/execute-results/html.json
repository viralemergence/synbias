{
  "hash": "ebfff605a80e7be6c3f6b08711071e35",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Analysis of Community Coinfection in Empirical Data\"\nauthor: \"July Pilowsky\"\nbibliography: references.bib\nformat: html\neditor: visual\ntoc: true\ncode-fold: true\nlightbox: true\ntheme: materia\n---\n\n\n::: {.cell}\n\n:::\n\n\n# Hechinger et al. snail data\n\n## About the data\n\nKevin Lafferty and Tara Stewart Merrill and colleagues collected data from intertidal snails (*Cerithidopsis californica*) at Carpinteria Salt Marsh Reserve from 2012 to 2014, dissecting 58 per site per month to find all of the trematode parasites (out of 20 species.) This parasite community has already been well-characterized in its interactions [@lafferty1994] and is known to be strongly competitive, with some trematodes known to be stronger competitors than others.\n\n## Analytical approach\n\nFirst, all analyses will be broken down by site and month to remove the possible effect of spatial clustering on coinfection. I am only comparing snails surveyed in the same place.\n\nSecond, I will characterize the overall structure of community interactions among trematodes. I will do this using a probabilistic model of species co-occurrence (Veech 2012) to find positive and negative associations between trematodes, and note which associations are common across points in space, and which pairs consistently have those associations.\n\nThird, I will test theoretical predictions from our simulation model, namely that error in species diversity estimates will increase with more competitive interactions in a community and decrease with more facilitative interactions. I will do this by artificially decreasing the sample size of observations and comparing those estimates to the true figures from the full sample size.\n\n## Community Structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnail <- read_csv(here(\"Data/Empirical/Trematode Infections.csv\"))\ntrematodes <- snail |>\n  select(starts_with(\"trematode\")) |>\n  flatten_chr() |>\n  unique() |>\n  discard(\n    .x = _,\n    ~ is.na(.x)\n  ) |>\n  discard(\n    .x = _,\n    ~ str_detect(.x, \"\\\\?\")\n  ) |>\n  discard(\n    .x = _,\n    ~ str_detect(.x, \"\\\\*\")\n  ) |>\n  discard(\n    .x = _,\n    ~ str_detect(.x, \"\\\\.\")\n  ) |>\n  discard(\n    .x = _,\n    ~ str_detect(.x, \"^im.+\")\n  ) |>\n  discard(.x = _, ~ .x == \"u\")\nsnail_data_prep <- function(df) {\n  all_snails <- df |>\n    rownames_to_column(\"ID\") |>\n    select(ID) |>\n    distinct()\n\n  processed_data <- df |>\n    rownames_to_column(\"ID\") |>\n    pivot_longer(\n      cols = starts_with(\"trematode\"),\n      names_to = \"trematode_survey\",\n      values_to = \"trematode\"\n    ) |>\n    filter(trematode %in% trematodes) |>\n    select(ID, trematode) |>\n    distinct() |>\n    mutate(presence = TRUE)\n\n  all_snails |>\n    cross_join(tibble(trematode = unique(processed_data$trematode))) |>\n    left_join(processed_data, by = c(\"ID\", \"trematode\")) |>\n    mutate(presence = coalesce(presence, FALSE)) |>\n    pivot_wider(\n      names_from = trematode,\n      values_from = presence,\n      id_cols = ID\n    ) |>\n    column_to_rownames(var = \"ID\") |>\n    as.matrix() |>\n    t()\n}\ncooccurrence_matrices <- snail |>\n  group_by(site) |>\n  group_split() |>\n  map(snail_data_prep)\ncooccurrence_analyses <- cooccurrence_matrices |>\n  map(\\(m) quiet(cooccur(m, thresh = F, spp_names = TRUE, prob = \"comb\")))\ncompetitive_pairs <- cooccurrence_analyses |>\n  map(\"results\") |>\n  map(\\(df) {\n    df |>\n      filter(exp_cooccur >= 1, p_lt < 0.05) |>\n      select(sp1_name, sp2_name, obs_cooccur, exp_cooccur, p_lt)\n  })\nfacilitative_pairs <- cooccurrence_analyses |>\n  map(\"results\") |>\n  map(\\(df) {\n    df |>\n      filter(exp_cooccur >= 1, p_gt < 0.05) |>\n      select(sp1_name, sp2_name, obs_cooccur, exp_cooccur, p_gt)\n  })\ndata.frame(\n  site = unique(snail$site),\n  facilitative = map_int(facilitative_pairs, nrow),\n  competitive = -map_int(competitive_pairs, nrow)\n) |>\n  ggplot(aes(x = site)) +\n  geom_col(\n    aes(y = facilitative),\n    fill = \"#EF7C12FF\",\n    alpha = 0.7,\n    width = 0.6\n  ) +\n  geom_col(aes(y = competitive), fill = \"#007BC3FF\", alpha = 0.7, width = 0.6) +\n  geom_hline(yintercept = 0, color = \"black\", linewidth = 1) +\n  labs(\n    title = \"Facilitative vs Competitive Interactions by Site\",\n    x = \"Site\",\n    y = \"Count (Facilitative above, Competitive below)\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/community structure-1.png){width=2100}\n:::\n:::\n\n\nWe can see from this plot that negative associations between species (indicating competition within hosts) are much more common than positive associations (indicating facilitation between parasites.) This graph only includes those associations considered to be significant (that is to say, the probability that species co-occur less than expected (or more than expected) is less than 0.05.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrematode_stats <- snail |>\n  pivot_longer(\n    cols = starts_with(\"trematode\"),\n    names_to = \"trematode_survey\",\n    values_to = \"trematode\"\n  ) |>\n  group_by(`Snail no.`, site) |>\n  reframe(infection_intensity = 1 - str_count(trematode, \"^u$\")) |>\n  filter(!is.na(infection_intensity)) |>\n  group_by(site) |>\n  summarize(sum_infection_intensity = sum(infection_intensity))\ndf_cf <- snail |>\n  pivot_longer(\n    cols = starts_with(\"trematode\"),\n    names_to = \"trematode_survey\",\n    values_to = \"trematode\"\n  ) |>\n  filter(trematode %in% trematodes) |>\n  group_by(site) |>\n  summarize(true_species_richness = n_distinct(trematode)) |>\n  ungroup() |>\n  mutate(\n    facilitative_pairs = map_int(facilitative_pairs, nrow),\n    competitive_pairs = map_int(competitive_pairs, nrow)\n  ) |>\n  left_join(trematode_stats, by = join_by(site))\ndf_cf <- snail |>\n  group_by(site) |>\n  summarize(sample_size = n()) |>\n  right_join(df_cf, by = join_by(site))\ndf_cf |>\n  ggplot() +\n  geom_point(\n    aes(x = sum_infection_intensity, y = facilitative_pairs),\n    color = \"#EF7C12FF\"\n  ) +\n  geom_smooth(\n    aes(x = sum_infection_intensity, y = facilitative_pairs),\n    color = \"#F4B95AFF\",\n    method = \"loess\",\n    formula = 'y ~ x',\n    se = F\n  ) +\n  geom_point(\n    aes(x = sum_infection_intensity, y = competitive_pairs),\n    color = \"#007BC3FF\"\n  ) +\n  geom_smooth(\n    aes(x = sum_infection_intensity, y = competitive_pairs),\n    color = \"#54BCD1FF\",\n    method = \"loess\",\n    formula = 'y ~ x',\n    se = F\n  ) +\n  ggtitle(\n    \"Infection Intensity as Confounder (blue = competitive, orange = facilitative)\"\n  ) +\n  ylab(\"# of Interacting Pairs\") +\n  xlab(\"Infection Intensity\")\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/competition-facilitation-1.png){width=2100}\n:::\n\n```{.r .cell-code}\ndf_cf |>\n  ggplot() +\n  geom_point(\n    aes(x = true_species_richness, y = facilitative_pairs),\n    color = \"#EF7C12FF\"\n  ) +\n  geom_smooth(\n    aes(x = true_species_richness, y = facilitative_pairs),\n    color = \"#F4B95AFF\",\n    method = \"loess\",\n    formula = 'y ~ x',\n    se = F\n  ) +\n  geom_point(\n    aes(x = true_species_richness, y = competitive_pairs),\n    color = \"#007BC3FF\"\n  ) +\n  geom_smooth(\n    aes(x = true_species_richness, y = competitive_pairs),\n    color = \"#54BCD1FF\",\n    method = \"loess\",\n    formula = 'y ~ x',\n    se = F\n  ) +\n  ggtitle(\n    \"Species Richness as Confounder (blue = competitive, orange = facilitative)\"\n  ) +\n  ylab(\"# of Interacting Pairs\") +\n  xlab(\"Species Richness\")\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/competition-facilitation-2.png){width=2100}\n:::\n\n```{.r .cell-code}\ndf_cf |>\n  ggplot() +\n  geom_point(\n    aes(x = sample_size, y = facilitative_pairs),\n    color = \"#EF7C12FF\"\n  ) +\n  geom_smooth(\n    aes(x = sample_size, y = facilitative_pairs),\n    color = \"#F4B95AFF\",\n    method = 'lm',\n    se = F\n  ) +\n  geom_point(\n    aes(x = sample_size, y = competitive_pairs),\n    color = \"#007BC3FF\"\n  ) +\n  geom_smooth(\n    aes(x = sample_size, y = competitive_pairs),\n    color = \"#54BCD1FF\",\n    se = F,\n    method = 'lm'\n  ) +\n  ggtitle(\n    \"Sample size as Confounder  (blue = competitive, orange = facilitative)\"\n  ) +\n  ylab(\"# of Interacting Pairs\") +\n  xlab(\"# of Snails sampled at site\")\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/competition-facilitation-3.png){width=2100}\n:::\n:::\n\n\nWe can see here that there are variables that are correlated with the number of competitive and facilitative pairs. Species richness of parasites is positively correlated with competitive but not facilitative pairs. Infection intensity is the same.\n\nVery importantly, there is variation among sites in how many snails were sampled, and many more competing pairs were detected at sites which a high sample size than at sites with a low sample size, while facilitating pairs were detected at nearly the same frequency. This is exactly the theoretical expectation: competing pairs are easy to miss if you don't sample enough.\n\nI can effectively fill in this graph with more points by randomly subsampling the high sample size sites down to lower sample sizes, and see if the pattern holds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(furrr)\nplan(multicore)\n\nsetDT(snail)\nsetDT(df_cf)\nn_sims <- 15\n\n# Define sites and trematodes to keep\nsites_to_keep <- c(\"c2\", \"c3\", \"c7\", \"c8\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\")\n\n# --- Helper function for analysis within data.table ---\nanalyze_site_dt <- function(site_data) {\n  # 1. Prepare matrix\n  matrix <- snail_data_prep(site_data)\n\n  # 2. Handle cases where matrix is too small for cooccur\n  if (!is.matrix(matrix) || nrow(matrix) < 2 || ncol(matrix) < 2) {\n    return(list(competitive = 0L, facilitative = 0L))\n  }\n\n  # 3. Run cooccur and get results\n  cooccur_res <- quiet(cooccur(\n    matrix,\n    thresh = F,\n    spp_names = TRUE,\n    prob = \"comb\"\n  ))\n  results_df <- setDT(cooccur_res$results)\n\n  # 4. Calculate counts directly from the results\n  if (is.null(results_df)) {\n    return(list(competitive = 0L, facilitative = 0L))\n  }\n\n  competitive_count <- nrow(results_df[exp_cooccur >= 1 & p_lt < 0.05])\n  facilitative_count <- nrow(results_df[exp_cooccur >= 1 & p_gt < 0.05])\n\n  # 5. Return a list of the final counts\n  list(competitive = competitive_count, facilitative = facilitative_count)\n}\n\n\nbootstrap_detect <- future_map(\n  rep(50:1200, n_sims),\n  function(x) {\n    subsample_dt <- snail[\n      site %in% sites_to_keep,\n      .SD[sample(.N, size = x)],\n      by = site\n    ]\n\n    pair_counts_dt <- subsample_dt[, analyze_site_dt(.SD), by = site]\n    setnames(\n      pair_counts_dt,\n      c(\"site\", \"competitive_pairs_estimate\", \"facilitative_pairs_estimate\")\n    )\n\n    melted_subsample <- melt(\n      subsample_dt,\n      id.vars = c(\"Snail no.\", \"site\"),\n      measure.vars = patterns(\"^trematode\"),\n      value.name = \"trematode\"\n    )[trematode %in% trematodes]\n\n    richness_dt <- unique(\n      melted_subsample,\n      by = c(\"Snail no.\", \"trematode\", \"site\")\n    )[, .(richness_estimate = .N), by = site]\n\n    results_dt <- df_cf[richness_dt, on = \"site\"][pair_counts_dt, on = \"site\"]\n    results_dt[,\n      bias := abs(true_species_richness - richness_estimate) /\n        true_species_richness\n    ]\n    results_dt[, downsample_size := x]\n\n    return(results_dt)\n  },\n  .progress = TRUE\n) |>\n  rbindlist()\n\nbootstrap_detect |>\n  mutate(\n    bias = abs(true_species_richness - richness_estimate) /\n      true_species_richness\n  ) |>\n  tidyplot(x = facilitative_pairs, y = bias) |>\n  add_data_points_beeswarm(color = \"#C70E7BFF\", alpha = 0.4) |>\n  add_curve_fit(method = \"lm\", color = \"#FC6882FF\", linewidth = 3) |>\n  adjust_y_axis_title(\"Bias in Species Richness Estimate\") |>\n  adjust_x_axis_title(\"Number of Facilitative Pairs\")\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/simulate detectability-1.png){width=2100}\n:::\n\n```{.r .cell-code}\nbootstrap_detect |>\n  mutate(\n    bias = abs(true_species_richness - richness_estimate) /\n      true_species_richness\n  ) |>\n  tidyplot(x = competitive_pairs, y = bias) |>\n  add_data_points_beeswarm(color = \"#C70E7BFF\", alpha = 0.4) |>\n  add_curve_fit(method = \"lm\", color = \"#FC6882FF\", linewidth = 3)\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/simulate detectability-2.png){width=2100}\n:::\n:::\n\n\nThere is pretty much no effect of facilitative or competitive pairs on the bias in species richness estimates. However, there may be some effect of sample size, infection intensity, and true species richness on bias. Later I will use a correlogram to try to get at confounding variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap_detect |> \n  ggplot(aes(x = downsample_size)) +\n  geom_jitter(aes(y = facilitative_pairs_estimate), color = \"#EF7C12FF\", alpha = 0.5) +\n  geom_jitter(aes(y = competitive_pairs_estimate), color = \"#007BC3FF\", alpha = 0.5) +\n  geom_smooth(aes(y = facilitative_pairs_estimate), color = \"#F4B95AFF\", method = \"gam\", alpha = 0.7, linewidth = 2) +\n  geom_smooth(aes(y = competitive_pairs_estimate), color = \"#54BCD1FF\", method = \"gam\", alpha = 0.7, linewidth = 2) +\n  geom_point(data = df_cf, aes(x = sample_size, y = facilitative_pairs), color = \"#EF7C12FF\", size = 4, shape = 18) +\n  geom_point(data = df_cf, aes(x = sample_size, y = competitive_pairs), color = \"#007BC3FF\", size = 4, shape = 18) +\n  theme_minimal() +\n  labs(\n    title = \"Interaction Accumulation Curve (blue = competitive, orange = facilitative)\",\n    x = \"# of Snails Sampled at Site\",\n    y = \"Number of Interacting Pairs\"\n  )\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/interaction accumulation curve-1.png){width=2100}\n:::\n:::\n\n\nThe true field samples are marked here with diamonds, while the simulated samples are marked with points.\n\nNow this result perfectly fits the theoretical expectation: the number of competitive pairs increases sharply with sample size, while the number of facilitative pairs saturates more quickly. This is because competitive pairs are more likely to be missed at low sample sizes. The accumulation curve has not yet leveled off for competitive pairs, even at 1300 snails sampled, which suggests that there are still more competitive pairs to be found at higher sample sizes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap_detect |> \n  ungroup() |>\n  mutate(bias = abs(true_species_richness - richness_estimate)/true_species_richness) |> \n  select(\n    bias,\n    true_species_richness,\n    sum_infection_intensity,\n    downsample_size,\n    facilitative_pairs,\n    competitive_pairs\n  ) |>\n  ggpairs()\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/correlations-1.png){width=2100}\n:::\n:::\n\n\nCompetitive pairs are very strongly correlated with infection intensity, nearly 1:1, while facilitative pairs are more weakly correlated. Controlling for infection intensity will likely remove the effect of competitive pairs on bias, but let's check.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4)\nlibrary(broom.mixed)\n\nbias <- bootstrap_detect$bias\nfixed_effects <- as.matrix(bootstrap_detect |>\n  select(\n    downsample_size,\n    true_species_richness,\n    sum_infection_intensity,\n    facilitative_pairs,\n    competitive_pairs\n  ))\nrandom_effects <- as.matrix(bootstrap_detect$site)\n\ngp_model <- fitGPModel(\n  likelihood = \"gaussian\",\n  group_data = random_effects,\n  y = bias,\n  X = fixed_effects,\n  params = list(std_dev = TRUE)\n)\n\ngp_model |>\n  get_coef() |>\n  t() |>\n  as.data.frame() |> \n  rownames_to_column(\"term\") |>\n  mutate(term = str_replace_all(term, \"_\", \" \")) |>\n  mutate(term = str_to_title(term)) |>\n  mutate(\n    term = factor(\n      term,\n      levels = c(\n        \"Downsample Size\",\n        \"True Species Richness\",\n        \"Infection Intensity\",\n        \"Facilitative Pairs\",\n        \"Competitive Pairs\"\n      )\n    ),\n    upper = `Param.` + `Std. dev.`,\n    lower = `Param.` - `Std. dev.`\n  ) |>\n  ggplot(aes(x = term, y = `Param.`)) +\n  geom_col(fill = \"#FC6882FF\") +\n  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +\n  labs(\n    title = \"Fixed Effects on Species Estimate Bias\",\n    x = \"Term\",\n    y = \"Estimate\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/lmm-1.png){width=2100}\n:::\n:::\n\n\nSample size and true species richness are significant predictors of bias in species richness estimates (there is more bias at low sample size and high species richness). Competition and facilatition are too confounded with infection intensity to have any effect, it seems.\n\nAnother idea I want to explore is to fit species accumulation curves to the number of competitive and facilitative pairs and use them to calculate how many snails one needs to sample in order to find all of the pairs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom)\n\n# Fit models for facilitative pairs\nfacilitative_data <- bootstrap_detect %>%\n  select(downsample_size, facilitative_pairs_estimate) %>%\n  na.omit()\n\n# Try different approaches for negative exponential fitting\nfit_negexp_safe <- function(data, y_col) {\n  tryCatch(\n    {\n      # Better starting values\n      max_y <- max(data[[y_col]])\n      # Use a simple exponential approach: y = a * (1 - exp(-b * x))\n      nls(\n        as.formula(paste(y_col, \"~ a * (1 - exp(-b * downsample_size))\")),\n        data = data,\n        start = list(a = max_y * 1.2, b = 0.01),\n        control = nls.control(maxiter = 100, warnOnly = TRUE)\n      )\n    },\n    error = function(e) {\n      # If that fails, try Michaelis-Menten: y = (a * x) / (b + x)\n      tryCatch(\n        {\n          nls(\n            as.formula(paste(\n              y_col,\n              \"~ (a * downsample_size) / (b + downsample_size)\"\n            )),\n            data = data,\n            start = list(\n              a = max(data[[y_col]]) * 2,\n              b = median(data$downsample_size)\n            )\n          )\n        },\n        error = function(e2) NULL\n      )\n    }\n  )\n}\n\n# Fit models\nfac_negexp <- fit_negexp_safe(facilitative_data, \"facilitative_pairs_estimate\")\n\n# Logarithmic: y = a * log(x + 1) + b\nfac_log <- nls(\n  facilitative_pairs_estimate ~ a * log(downsample_size + 1) + b,\n  data = facilitative_data,\n  start = list(a = 1, b = 0)\n)\n\n# Fit models for competitive pairs\ncompetitive_data <- bootstrap_detect %>%\n  select(downsample_size, competitive_pairs_estimate) %>%\n  na.omit()\n\n# Negative exponential\ncomp_negexp <- fit_negexp_safe(competitive_data, \"competitive_pairs_estimate\")\n\n# Logarithmic\ncomp_log <- nls(\n  competitive_pairs_estimate ~ a * log(downsample_size + 1) + b,\n  data = competitive_data,\n  start = list(a = 1, b = 0)\n)\n\n# Create prediction data\npred_x <- seq(\n  1,\n  max(bootstrap_detect$downsample_size, na.rm = TRUE),\n  length.out = 100\n)\n\n# Generate predictions\nfac_negexp_pred <- predict(\n  fac_negexp,\n  newdata = data.frame(downsample_size = pred_x)\n)\nfac_log_pred <- predict(fac_log, newdata = data.frame(downsample_size = pred_x))\ncomp_negexp_pred <- predict(\n  comp_negexp,\n  newdata = data.frame(downsample_size = pred_x)\n)\ncomp_log_pred <- predict(\n  comp_log,\n  newdata = data.frame(downsample_size = pred_x)\n)\n\n# Create prediction dataframe\npred_data <- data.frame(\n  downsample_size = rep(pred_x, 4),\n  predicted = c(fac_negexp_pred, fac_log_pred, comp_negexp_pred, comp_log_pred),\n  interaction_type = rep(\n    c(\"facilitative\", \"facilitative\", \"competitive\", \"competitive\"),\n    each = 100\n  ),\n  model_type = rep(\n    c(\"neg_exp\", \"logarithmic\", \"neg_exp\", \"logarithmic\"),\n    each = 100\n  )\n)\n\n# Plot with fitted curves\nbootstrap_detect %>%\n  ggplot(aes(x = downsample_size)) +\n  geom_jitter(\n    aes(y = facilitative_pairs_estimate),\n    color = \"#EF7C12FF\",\n    alpha = 0.5\n  ) +\n  geom_jitter(\n    aes(y = competitive_pairs_estimate),\n    color = \"#007BC3FF\",\n    alpha = 0.5\n  ) +\n  geom_smooth(\n    aes(y = facilitative_pairs_estimate),\n    color = \"#F4B95AFF\",\n    method = \"gam\",\n    alpha = 0.7,\n    size = 2\n  ) +\n  geom_smooth(\n    aes(y = competitive_pairs_estimate),\n    color = \"#54BCD1FF\",\n    method = \"gam\",\n    alpha = 0.7,\n    size = 2\n  ) +\n  # Add fitted curves\n  geom_line(\n    data = filter(\n      pred_data,\n      interaction_type == \"facilitative\",\n      model_type == \"neg_exp\"\n    ),\n    aes(y = predicted),\n    color = \"#F4B95AFF\",\n    linetype = \"dashed\",\n    size = 2.5\n  ) +\n  geom_line(\n    data = filter(\n      pred_data,\n      interaction_type == \"facilitative\",\n      model_type == \"logarithmic\"\n    ),\n    aes(y = predicted),\n    color = \"#F4B95AFF\",\n    linetype = \"dotted\",\n    size = 2.5\n  ) +\n  geom_line(\n    data = filter(\n      pred_data,\n      interaction_type == \"competitive\",\n      model_type == \"neg_exp\"\n    ),\n    aes(y = predicted),\n    color = \"#54BCD1FF\",\n    linetype = \"dashed\",\n    size = 2.5\n  ) +\n  geom_line(\n    data = filter(\n      pred_data,\n      interaction_type == \"competitive\",\n      model_type == \"logarithmic\"\n    ),\n    aes(y = predicted),\n    color = \"#54BCD1FF\",\n    linetype = \"dotted\",\n    size = 2.5\n  ) +\n\n  geom_point(\n    data = df_cf,\n    aes(x = sample_size, y = facilitative_pairs),\n    color = \"#EF7C12FF\",\n    size = 4,\n    shape = 18\n  ) +\n  geom_point(\n    data = df_cf,\n    aes(x = sample_size, y = competitive_pairs),\n    color = \"#007BC3FF\",\n    size = 4,\n    shape = 18\n  ) +\n  theme_minimal() +\n  scale_y_continuous(limits = c(0, NA)) +\n  labs(\n    title = \"Interaction Accumulation Curves with Fitted Models\",\n    subtitle = \"Dashed = Negative Exponential, Dotted = Logarithmic, Solid = Fitted GAM\",\n    x = \"# of Snails Sampled at Site\",\n    y = \"Number of Interacting Pairs\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ s(x, bs = \"cs\")'\n`geom_smooth()` using formula = 'y ~ s(x, bs = \"cs\")'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/accumulation curves-1.png){width=2100}\n:::\n:::\n\n\nThe logarithmic and negative exponential models fit the observed trends in facilatitive pairs well, but the competitive pairs don't fit the models at all. This is likely because competitive pairs are still accumulating rapidly at the highest sample sizes, while facilitative pairs have already saturated.\n\n## By Species\n\nWhat are these competing pairs, anyway? Let's return to the field data and pull out the pairs that are consistently competitive or facilitative across sites.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacilitative_pairs |> \n  map(\\(df) select(df, sp1_name, sp2_name)) |>\n  bind_rows() |> \n  group_by(sp1_name, sp2_name) |>\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n# Groups:   sp1_name [1]\n  sp1_name sp2_name     n\n  <chr>    <chr>    <int>\n1 euha     aust         1\n2 euha     renb         2\n3 euha     smcy         7\n```\n\n\n:::\n:::\n\n\nMost of the time, the facilatitive pair is *Euhaplorchis californiensis* and small cyathocotylid trematodes (7/10 pairs). THere are also 2 instances of *E. californiensis* and *Renicola buchanani* being facilitative, and one instance of *E. californiensis* and *Austrobilharzia* sp. being facilitative.\n\nNow let's look at the competitive pairs, which should be well-established from lab experiments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompetitive_pairs |> \n  map(\\(df) select(df, sp1_name, sp2_name)) |>\n  bind_rows() |> \n  group_by(sp1_name, sp2_name) |>\n  summarize(n = n()) |> \n  print(n = 41)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 41 × 3\n# Groups:   sp1_name [10]\n   sp1_name sp2_name     n\n   <chr>    <chr>    <int>\n 1 cloa     euha         1\n 2 cloa     himb         2\n 3 euha     acan         2\n 4 euha     cata         1\n 5 euha     cloa         5\n 6 euha     hima         6\n 7 euha     himb         7\n 8 euha     meso         2\n 9 euha     paro         4\n10 euha     phoc         2\n11 euha     prob         2\n12 euha     pygi         4\n13 euha     repo         1\n14 euha     stic         6\n15 hima     acan         1\n16 hima     cloa         1\n17 hima     euha         2\n18 hima     himb         3\n19 hima     meso         1\n20 hima     paro         1\n21 hima     renb         1\n22 hima     smcy         1\n23 hima     stic         1\n24 himb     acan         1\n25 himb     cata         1\n26 himb     cloa         2\n27 himb     euha         2\n28 himb     hima         3\n29 himb     meso         1\n30 himb     prob         1\n31 himb     pygi         1\n32 himb     renb         1\n33 himb     repo         1\n34 himb     smcy         2\n35 himb     stic         3\n36 meso     euha         1\n37 paro     himb         2\n38 prob     euha         1\n39 renb     himb         2\n40 smcy     himb         2\n41 stic     euha         1\n```\n\n\n:::\n:::\n\n\n# Tara's *Daphnia* data\n\n## About the data\n\nTara Stewart Merrill and colleagues sampled *Daphnia* in multiple lakes at multiple timepoints in multiple lakes in 2017, extending over the productive season of the lakes (June-Dec.) The nice thing about this system for coinfection is that the system \"resets\" every year: a new crop of juvenile *Daphnia* emerge in the spring without any parasites, then get infected.\n\n## Analytical approach\n\nThe difference in approach here is that I have to control for time. While the snails, above, are long-lived and accumulate their parasite load over years, *Daphnia* are ephemeral, and associations between parasites may be the result of temporal clustering.\n\n## Community Structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaphnia_data_prep <- function(df) {\n  df |>\n    pivot_longer(\n      cols = contains(\"status\"),\n      names_to = \"Parasite\",\n      values_to = \"presence\"\n    ) |>\n    select(id = `data order`, Parasite, presence) |>\n    distinct() |>\n    mutate(\n      presence = presence == \"u\",\n      Parasite = str_split_i(Parasite, \" \", 1)\n    ) |>\n    pivot_wider(\n      names_from = Parasite, # The species names become columns\n      values_from = presence, # TRUE/FALSE based on presence\n      values_fill = FALSE, # Fill absent species with FALSE\n      id_cols = id,\n      id_expand = TRUE\n    ) |>\n    column_to_rownames(var = \"id\") |>\n    as.matrix() |>\n    t()\n}\ncooccurrence_matrices <- daphnia |>\n  group_by(lake, `date collected`) |>\n  group_split() |>\n  map(daphnia_data_prep)\ncooccurrence_analyses <- cooccurrence_matrices |>\n  map(\\(m) quiet(cooccur(m, thresh = T, spp_names = TRUE, prob = \"comb\")))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaphnia |> \n  group_by(lake, `date collected`) |> \n  group_keys() |> \n  mutate(\n    positive = map_int(cooccurrence_analyses, \"positive\"),\n    negative = map_int(cooccurrence_analyses, \"negative\")\n  ) |> \n    pivot_longer(\n      cols = c(positive, negative),\n      names_to = \"association\",\n      values_to = \"count\"\n    ) |>\n  ggplot() +\n  geom_histogram(aes(x = count, fill = association), bins = 2, position = \"dodge\") +\n  xlab(\"Number of Associations per Site/Month\") +\n  ggtitle(\"Species Associations (blue = positive, orange = negative)\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/plot daphnia associations-1.png){width=2100}\n:::\n:::\n\n\nThis result is very different from the snail/trematode system. The associations are much more likely to be neutral, and there doesn't seem to be any salient difference in positive vs. negative associations.\n\n## By Species\n\nAgain, I want to look at the specific species pairs involved here and get a sense of whether the (few) species pairs with positive or negative interactions are consistent in space and time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacilitative_pairs_daphnia <- cooccurrence_analyses |> \n  map(\"results\") |> \n  map(\\(df) df |> filter(p_gt < 0.05)) |>\n  map(\\(df) select(df, sp1_name, sp2_name)) |> \n  bind_rows()\ncompetitive_pairs_daphnia <- cooccurrence_analyses |>\n  map(\"results\") |> \n  map(\\(df) df |> filter(p_lt < 0.05)) |>\n  map(\\(df) select(df, sp1_name, sp2_name)) |> \n  bind_rows()\nfacilitative_pairs_daphnia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   sp1_name      sp2_name\n1 Pasteuria Spirobacillus\n2      MicG           GPB\n3       GP2           GPB\n4        BP            BC\n```\n\n\n:::\n\n```{.r .cell-code}\ncompetitive_pairs_daphnia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  sp1_name sp2_name\n1     MicG       GP\n2     MicG       GP\n```\n\n\n:::\n:::\n\n\nThese results indicate that there are very few species pairs that are competitive or facilitative across sites and times (two competitive pairs and three facilitative pairs). This seems to be because the sample sizes are much lower:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaphnia |> \n  group_by(lake, `date collected`) |> \n  summarize(sample_size = n()) |>\n  ggplot(aes(x = sample_size)) +\n  geom_histogram(bins = 20) +\n  xlab(\"Sample Size\") +\n  ylab(\"Count\") +\n  ggtitle(\"Sample Sizes in Daphnia Data\")\n```\n\n::: {.cell-output-display}\n![](empirical_analysis_files/figure-html/daphnia sample sizes-1.png){width=2100}\n:::\n:::\n\n\nThese kinds of sample sizes in the snail dataset were insufficient to detect more than a couple of pairs. Of course, this loss of sample size is due to the fact that I had to group the data by time as well as place, due to the ephemeral nature of *Daphnia*.",
    "supporting": [
      "empirical_analysis_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}