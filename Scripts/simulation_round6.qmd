---
title: "Coinfection bias simulations: round 6"
format: html
---

```{r setup}
library(poems)
library(tidyverse)
library(furrr)
library(Rcpp)
library(qs)
library(here)
library(data.table)
library(mgcv)
library(gratia)
library(parallel)
source(here("Scripts/simulation_functions.R"))
sourceCpp(here("Scripts/ferrari.cpp"))
options(future.globals.maxSize= 9967869120)
data_dir <- here("Data/simulation_round6")
simulate <- TRUE
```

# Rationale

In this round of simulations, I am trying out a new approach. Previously, we generated pairwise interactions between strains using a C:F ratio to divide matrices between competition and facilitation, then interaction strength to determine the bounds of the uniform distribution of competition and facilitation from which the values would be drawn. This time, we will generate pairwise interactions from a normal distribution, with the CF ratio shaping the mean and interaction strength shaping the SD. The actual outbreak simulations, and all other aspects, remain the same.

# Generate inputs

```{r generate inputs}
set.seed(1800)
DFList <- 
  1:10000 %>% 
  map(function(a){
    
    data.frame(id = a, 
               interaction_strength = runif(1, 0, 0.3),
               cf_ratio = runif(1, 0.7, 1.3),
               priority_effects = F,
               strains = round(runif(1, 5, 100)), 
               sample_prop = runif(1, 0.1, 1))
    
  })
inputs <- DFList %>%
  map(function(df) {
    int_matrix <- matrix(1, nrow = df$strains, ncol = df$strains)
    int_matrix[] <- rnorm(n = df$strains*df$strains, mean = df$cf_ratio, sd = df$interaction_strength)
    diag(int_matrix) <- 1
    initial_pop <- c(rep(c(1, rep(0, df$strains)), df$strains),
                    rep(0, df$strains*1000 - df$strains*(df$strains+1))) |>
      matrix(nrow = 1000, byrow = T)
    return(list(initial_pop = initial_pop, interactions = int_matrix))
  })
strainDF <- inputs %>% 
  map("interactions") |>
  map(function(a){
    
    Comp <- a
    Comp[Comp > 1] <- 0
    Comp <- abs(Comp-1)
    Comp[Comp == 1] <- 0
    
    Fac <- a
    Fac[Fac < 1] <- 0
    Fac <- Fac-1
    Fac[Fac == -1] <- 0
    
    diag(Comp) <- diag(Fac) <- 0
    
    data.frame(CompStrength = rowSums(Comp),
               FacStrength = rowSums(Fac),
               CompMeans = rowMeans(Comp),
               FacMeans = rowMeans(Fac),
               Strain = 1:nrow(a))
    
  }) %>% bind_rows(.id = "id") %>% 
  mutate(id = as.numeric(id)) |>
  left_join(DFList |> bind_rows()) |>
  mutate(TotalStrength = CompStrength + FacStrength, 
                   TotalMean = CompMeans + FacMeans)

summary(strainDF)
write_csv(strainDF, here("Data/simulation_round6/simulation_round6_inputs.csv"))
setDT(strainDF)
```

# Simulate

```{r simulate}
if (simulate) {
  future_walk(1:length(inputs), \(x) {
    filename <- paste0(getwd(),
                       "/Data/simulation_round6/sim",
                       sample_data6$id[x],
                       ".qs")
    if (!file.exists(filename)) {
      sourceCpp("Scripts/ferrari.cpp")
      x <- inputs[[x]]
      mat <- ferrari(x$initial_pop, x$interactions, 2e-04, 100)
      qsave(mat, filename)
    }
  }, .progress = T)
}
```

# Sample

```{r sample}
disease_sample <- function(sim_number, prop) {
  matrix <- file.path(data_dir, paste0("sim", sim_number, ".qs")) |> qread()
  individuals <- round(prop*nrow(matrix))
  map(1:100, ~matrix[sample(1:nrow(matrix), individuals), , .]) |>
    abind::abind(along = 3) |> 
    colSums() |> 
    apply(c(1,2), as.logical) |> 
    array_branch(1) |> 
    map(\(dt) data.table(detect = dt, time = 1:100)) |> 
    map2(strainDF[id == sim_number] %>% split(seq_len(nrow(.))), cbind) |> 
    rbindlist()
}
plan(multisession)
detect_df <- future_map(1:10000, \(i) disease_sample(i, DFList[[i]]$sample_prop)) |>
  rbindlist()
```

# Analyze

## GAM

To check for nonlinearities.

```{r}
tensor_gam <- bam(detect ~ te(CompMeans, FacMeans) + s(strains) + s(sample_prop),
                  family = binomial(), data = detect_df,
                  cluster = makeCluster(2))
draw(tensor_gam)
```
