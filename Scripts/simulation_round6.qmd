---
title: "Coinfection bias simulations: round 6"
format: html
---

```{r setup}
library(poems)
library(tidyverse)
library(furrr)
library(Rcpp)
library(qs)
library(here)
library(data.table)
library(mgcv)
library(gratia)
library(parallel)
library(parglm)
source(here("Scripts/simulation_functions.R"))
sourceCpp(here("Scripts/ferrari.cpp"))
options(future.globals.maxSize= 9967869120)
data_dir <- here("Data/simulation_round6")
simulate <- FALSE
run_gam <- FALSE
```

# Rationale

In this round of simulations, I am trying out a new approach. Previously, we generated pairwise interactions between strains using a C:F ratio to divide matrices between competition and facilitation, then interaction strength to determine the bounds of the uniform distribution of competition and facilitation from which the values would be drawn. This time, we will generate pairwise interactions from a normal distribution, with the CF ratio shaping the mean and interaction strength shaping the SD. The actual outbreak simulations, and all other aspects, remain the same.

# Generate inputs

```{r generate inputs}
set.seed(1800)
DFList <- 
  1:10000 %>% 
  map(function(a){
    
    data.frame(id = a, 
               interaction_strength = runif(1, 0, 0.3),
               cf_ratio = runif(1, 0.7, 1.3),
               priority_effects = F,
               strains = round(runif(1, 5, 100)), 
               sample_prop = runif(1, 0.1, 1))
    
  })
inputs <- DFList %>%
  map(function(df) {
    int_matrix <- matrix(1, nrow = df$strains, ncol = df$strains)
    int_matrix[] <- rnorm(n = df$strains*df$strains, mean = df$cf_ratio, sd = df$interaction_strength)
    diag(int_matrix) <- 1
    initial_pop <- c(rep(c(1, rep(0, df$strains)), df$strains),
                    rep(0, df$strains*1000 - df$strains*(df$strains+1))) |>
      matrix(nrow = 1000, byrow = T)
    return(list(initial_pop = initial_pop, interactions = int_matrix))
  })
strainDF <- inputs %>% 
  map("interactions") |>
  map(function(a){
    
    Comp <- a
    Comp[Comp > 1] <- 0
    Comp <- abs(Comp-1)
    Comp[Comp == 1] <- 0
    
    Fac <- a
    Fac[Fac < 1] <- 0
    Fac <- Fac-1
    Fac[Fac == -1] <- 0
    
    diag(Comp) <- diag(Fac) <- 0
    
    data.frame(CompStrength = rowSums(Comp),
               FacStrength = rowSums(Fac),
               CompMeans = rowMeans(Comp),
               FacMeans = rowMeans(Fac),
               Strain = 1:nrow(a))
    
  }) %>% bind_rows(.id = "id") %>% 
  mutate(id = as.numeric(id)) |>
  left_join(DFList |> bind_rows()) |>
  mutate(TotalStrength = CompStrength + FacStrength, 
                   TotalMean = CompMeans + FacMeans)

summary(strainDF)
write_csv(strainDF, here("Data/simulation_round6/simulation_round6_inputs.csv"))
setDT(strainDF)
```

# Simulate

```{r simulate}
if (simulate) {
  future_walk(1:length(inputs), \(x) {
    filename <- paste0(getwd(),
                       "/Data/simulation_round6/sim",
                       sample_data6$id[x],
                       ".qs")
    if (!file.exists(filename)) {
      sourceCpp("Scripts/ferrari.cpp")
      x <- inputs[[x]]
      mat <- ferrari(x$initial_pop, x$interactions, 2e-04, 100)
      qsave(mat, filename)
    }
  }, .progress = T)
}
```

# Sample

```{r sample}
disease_sample <- function(sim_number, prop) {
  matrix <- file.path(data_dir, paste0("sim", sim_number, ".qs")) |> qread()
  individuals <- round(prop*nrow(matrix))
  map(1:100, ~matrix[sample(1:nrow(matrix), individuals), , .]) |>
    abind::abind(along = 3) |> 
    colSums() |> 
    apply(c(1,2), as.logical) |> 
    array_branch(1) |> 
    map(\(dt) data.table(detect = dt, time = 1:100)) |> 
    map2(strainDF[id == sim_number] %>% split(seq_len(nrow(.))), cbind) |> 
    rbindlist()
}
plan(sequential)
detect_df <- future_map(1:10000, \(i) disease_sample(i, DFList[[i]]$sample_prop)) |>
  rbindlist()
```

# Analyze

## GAM

To check for nonlinearities.

```{r gam}
if (run_gam) {
  tensor_gam <- bam(detect ~ te(CompMeans, FacMeans) + s(strains) + s(sample_prop),
                  family = binomial(), data = detect_df,
                  cluster = makeCluster(2))
  draw(tensor_gam)
}
```

## GLM

The behavior of the predictors does not look too far from linear, so I will go ahead and do some GLMs. Here is an analysis where I include population as a random effect and competition and facilitation as interactions with time.

```{r glm}
detect_glm <- parglm(detect ~ time + time:CompMeans + time:FacMeans + strains +
                sample_prop,
            data = detect_df,
            family = binomial, 
            control = parglm.control(nthreads = 3L))
library(ggplot2)
# Create a dataframe for the coefficients
coefficients <- data.frame(
  Term = c("time", "strains", "sample_prop", "time:CompMeans", "time:FacMeans"),
  Estimate = c(0.1667994, -0.0006991, 4.7302201, -0.2080439, 0.1072236)
)

# Plotting
ggplot(coefficients, aes(x = Term, y = Estimate, fill = Estimate > 0)) +
  geom_col() +
  coord_flip() +
  labs(title = "GLM Coefficients", x = "Terms", y = "Coefficient Value") +
  scale_fill_manual(values = c("red", "blue"), name = "Effect", labels = c("Negative", "Positive")) +
  theme_minimal()

# Generate a grid of values for 'time' and 'CompMeans'
time_values <- seq(min(detect_df$time), max(detect_df$time), length.out = 100)
comp_means_values <- seq(min(detect_df$CompMeans), max(detect_df$CompMeans), length.out = 100)

# Create a grid for prediction
prediction_grid <- expand.grid(time = time_values, CompMeans = comp_means_values)

# Assume mean values for other predictors for simplicity
mean_strains <- mean(detect_df$strains)
mean_sample_prop <- mean(detect_df$sample_prop)
mean_fac_means <- mean(detect_df$FacMeans)

# Add constant predictors
prediction_grid$strains <- mean_strains
prediction_grid$sample_prop <- mean_sample_prop
prediction_grid$FacMeans <- mean_fac_means

# Predict over the grid
prediction_grid$Predicted <- predict(detect_glm, newdata = prediction_grid, type = "response")

# Plot
ggplot(prediction_grid, aes(x = time, y = CompMeans, fill = Predicted)) +
  geom_tile() + # or use geom_raster() for large datasets
  scale_fill_gradient2(low = "purple", high = "green", mid = "white", midpoint = 0.8, 
                       name = "Probability") +
  labs(title = "Interaction Effect of 'time' and 'CompMeans'", 
       x = "Time", y = "CompMeans") +
  theme_minimal()
```
